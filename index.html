<!DOCTYPE html>
<html lang="pt-PT">
  <head>
    <meta charset="UTF-8">
    <title>Hugo Castanho</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { 
        margin: 0; 
        overflow: hidden; 
        background: #000; 
        font-family: 'Arial Black', Impact, sans-serif;
        cursor: none;
      }
      canvas { display: block; }
      
      #custom-cursor {
        position: fixed;
        width: 35px;
        height: 35px;
        border: 2px solid rgba(255, 50, 255, 0.9);
        border-radius: 50%;
        pointer-events: none;
        z-index: 10000;
        transition: all 0.1s ease;
        box-shadow: 0 0 20px rgba(255, 50, 255, 0.8);
        animation: pulse 1.5s infinite;
      }
      
      @keyframes pulse {
        0%, 100% { box-shadow: 0 0 20px rgba(255, 50, 255, 0.8); }
        50% { box-shadow: 0 0 35px rgba(255, 50, 255, 1); }
      }
      
      #info {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(255, 255, 255, 0.7);
        font-size: 13px;
        z-index: 1000;
        text-align: center;
        pointer-events: none;
        font-family: Arial, sans-serif;
        text-shadow: 0 0 10px rgba(255, 50, 255, 0.8);
      }
    </style>
  </head>
  <body>
    <div id="custom-cursor"></div>
    <div id="info">Mova o cursor • Clique para EXPLOSÃO ÉPICA</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js"></script>
    <script>
      let particles = [];
      const numParticles = 2000;
      let explosionForce = 0;
      let colorShift = 0;
      let explosionX = 0;
      let explosionY = 0;
      let shockwave = 0;
      
      function setup() {
        createCanvas(windowWidth, windowHeight);
        
        // Inicializa partículas em movimento constante
        for (let i = 0; i < numParticles; i++) {
          particles.push(new Particle(random(width), random(height)));
        }
      }
      
      function draw() {
        // Background com leve trail para efeito de movimento
        fill(0, 0, 0, 40);
        rect(0, 0, width, height);
        
        colorShift += 2;
        explosionForce *= 0.88;
        shockwave += 15;
        
        // Desenha shockwave da explosão
        if (shockwave < 500 && explosionForce > 5) {
          noFill();
          strokeWeight(3);
          stroke(255, 100, 255, map(shockwave, 0, 500, 200, 0));
          circle(explosionX, explosionY, shockwave);
          strokeWeight(2);
          stroke(100, 200, 255, map(shockwave, 0, 500, 150, 0));
          circle(explosionX, explosionY, shockwave * 0.7);
        }
        
        // Partículas de fundo vibrantes
        for (let p of particles) {
          p.update();
          p.show();
        }
        
        // Texto SUPER legível e vibrante
        drawVibrantText();
        
        // Cursor
        updateCursor();
      }
      
      function drawVibrantText() {
        push();
        translate(width / 2, height / 2);
        
        let pulse = sin(frameCount * 0.05) * 3;
        
        // Glow externo MUITO vibrante
        for (let i = 6; i > 0; i--) {
          let glowSize = i * 6;
          let glowAlpha = map(i, 0, 6, 150, 15);
          
          let hue = (colorShift * 3) % 360;
          let r = sin(radians(hue)) * 127 + 128;
          let g = sin(radians(hue + 120)) * 127 + 128;
          let b = sin(radians(hue + 240)) * 127 + 128;
          
          stroke(r, g, b, glowAlpha);
          strokeWeight(glowSize);
          noFill();
          textAlign(CENTER, CENTER);
          textSize(90 + pulse);
          textStyle(BOLD);
          text("CASTANHO.ME", 0, 0);
        }
        
        // Sombra colorida para profundidade
        stroke(255, 0, 255, 180);
        strokeWeight(8);
        noFill();
        textAlign(CENTER, CENTER);
        textSize(90 + pulse);
        textStyle(BOLD);
        text("CASTANHO.ME", 2, 2);
        
        // Contorno branco brilhante
        stroke(255, 255, 255, 255);
        strokeWeight(5);
        noFill();
        text("CASTANHO.ME", 0, 0);
        
        // Preenchimento branco sólido para MÁXIMA legibilidade
        noStroke();
        fill(255, 255, 255, 255);
        text("CASTANHO.ME", 0, 0);
        
        // Highlights cintilantes
        let numSparkles = 8;
        for (let i = 0; i < numSparkles; i++) {
          let angle = (frameCount * 0.02 + i * TWO_PI / numSparkles);
          let radius = 180 + sin(frameCount * 0.03 + i) * 20;
          let x = cos(angle) * radius;
          let y = sin(angle) * radius;
          
          let sparkleSize = 4 + sin(frameCount * 0.1 + i) * 2;
          
          noStroke();
          fill(255, 255, 0, 200);
          circle(x, y, sparkleSize * 2);
          fill(255, 255, 255, 255);
          circle(x, y, sparkleSize);
        }
        
        pop();
      }
      
      function updateCursor() {
        let cursor = document.getElementById('custom-cursor');
        if (cursor) {
          cursor.style.left = (mouseX - 17.5) + 'px';
          cursor.style.top = (mouseY - 17.5) + 'px';
          
          if (mouseIsPressed) {
            cursor.style.transform = 'scale(1.5)';
            cursor.style.borderColor = 'rgba(255, 255, 0, 1)';
          } else {
            cursor.style.transform = 'scale(1)';
            cursor.style.borderColor = 'rgba(255, 50, 255, 0.9)';
          }
        }
      }
      
      function mousePressed() {
        explosionForce = 35;
        explosionX = mouseX;
        explosionY = mouseY;
        shockwave = 0;
        
        let mousePos = createVector(mouseX, mouseY);
        
        // EXPLOSÃO ÉPICA
        for (let p of particles) {
          let d = dist(p.pos.x, p.pos.y, mouseX, mouseY);
          if (d < 400) {
            let force = p5.Vector.sub(p.pos, mousePos);
            force.normalize();
            force.mult(map(d, 0, 400, 25, 5));
            p.vel.add(force);
          }
        }
        
        // Adiciona partículas extras na explosão
        for (let i = 0; i < 50; i++) {
          let angle = random(TWO_PI);
          let speed = random(3, 10);
          let px = mouseX + cos(angle) * 5;
          let py = mouseY + sin(angle) * 5;
          let newP = new Particle(px, py);
          newP.vel.set(cos(angle) * speed, sin(angle) * speed);
          newP.lifespan = 100;
          particles.push(newP);
        }
      }
      
      function keyPressed() {
        if (key === ' ') {
          // Reset partículas que estão fora de bounds
          particles = particles.filter(p => !p.lifespan || p.lifespan > 0);
        }
      }
      
      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }
      
      class Particle {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.vel = createVector(random(-0.5, 0.5), random(-0.5, 0.5));
          this.acc = createVector(0, 0);
          this.size = random(2, 5);
          this.offset = random(1000);
          this.lifespan = null;
          this.rotation = random(TWO_PI);
          this.rotSpeed = random(-0.05, 0.05);
        }
        
        update() {
          // Movimento perpétuo vibrante
          let flowAngle = noise(this.pos.x * 0.005, this.pos.y * 0.005, frameCount * 0.01) * TWO_PI * 2;
          let flowForce = createVector(cos(flowAngle), sin(flowAngle));
          flowForce.mult(0.3);
          this.acc.add(flowForce);
          
          let d = dist(this.pos.x, this.pos.y, mouseX, mouseY);
          
          // Interação forte com mouse
          if (d < 150) {
            let force = p5.Vector.sub(this.pos, createVector(mouseX, mouseY));
            force.normalize();
            force.mult(map(d, 0, 150, 15, 0));
            this.acc.add(force);
          }
          
          this.vel.add(this.acc);
          this.vel.limit(6);
          this.vel.mult(0.98);
          this.pos.add(this.vel);
          this.acc.mult(0);
          
          this.rotation += this.rotSpeed;
          
          // Lifespan para partículas de explosão
          if (this.lifespan !== null) {
            this.lifespan--;
          }
          
          // Wrap around
          if (this.pos.x < -10) this.pos.x = width + 10;
          if (this.pos.x > width + 10) this.pos.x = -10;
          if (this.pos.y < -10) this.pos.y = height + 10;
          if (this.pos.y > height + 10) this.pos.y = -10;
        }
        
        show() {
          if (this.lifespan !== null && this.lifespan <= 0) return;
          
          let d = dist(this.pos.x, this.pos.y, mouseX, mouseY);
          let alpha = this.lifespan !== null ? map(this.lifespan, 0, 100, 0, 255) : 255;
          
          push();
          translate(this.pos.x, this.pos.y);
          rotate(this.rotation);
          
          noStroke();
          
          if (d < 180) {
            // SUPER vibrante perto do mouse
            let intensity = map(d, 0, 180, 255, 80);
            
            // Glow externo
            fill(255, intensity, 255, alpha * 0.6);
            circle(0, 0, this.size * 4);
            
            // Glow médio
            fill(255, 255, intensity, alpha * 0.8);
            circle(0, 0, this.size * 2);
            
            // Partícula principal
            fill(255, 255, 100, alpha);
            circle(0, 0, this.size);
            
            // Core brilhante
            fill(255, 255, 255, alpha);
            circle(0, 0, this.size * 0.4);
          } else {
            // Cores vibrantes em movimento
            let hue = (colorShift * 2 + this.offset) % 360;
            let r = sin(radians(hue)) * 127 + 128;
            let g = sin(radians(hue + 120)) * 127 + 128;
            let b = sin(radians(hue + 240)) * 127 + 128;
            
            // Glow
            fill(r, g, b, alpha * 0.4);
            circle(0, 0, this.size * 2.5);
            
            // Partícula
            fill(r, g, b, alpha);
            circle(0, 0, this.size);
          }
          
          pop();
        }
      }
      
      // Limpa partículas mortas periodicamente
      setInterval(() => {
        particles = particles.filter(p => !p.lifespan || p.lifespan > 0);
        if (particles.length < numParticles) {
          for (let i = particles.length; i < numParticles; i++) {
            particles.push(new Particle(random(width), random(height)));
          }
        }
      }, 2000);
    </script>
  </body>
</html>
