<!DOCTYPE html>
<html lang="pt-PT">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hugo Castanho</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { 
        margin: 0; 
        overflow: hidden; 
        background: #000; 
        font-family: 'Arial Black', Impact, sans-serif;
        cursor: none;
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
      canvas { display: block; }
      
      #custom-cursor {
        position: fixed;
        width: 35px;
        height: 35px;
        border: 2px solid rgba(255, 50, 255, 0.9);
        border-radius: 50%;
        pointer-events: none;
        z-index: 10000;
        transition: all 0.1s ease;
        box-shadow: 0 0 20px rgba(255, 50, 255, 0.8);
        animation: pulse 1.5s infinite;
      }
      
      @keyframes pulse {
        0%, 100% { box-shadow: 0 0 20px rgba(255, 50, 255, 0.8); }
        50% { box-shadow: 0 0 35px rgba(255, 50, 255, 1); }
      }
      
      #info {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(255, 255, 255, 0.7);
        font-size: 13px;
        z-index: 1000;
        text-align: center;
        pointer-events: none;
        font-family: Arial, sans-serif;
        text-shadow: 0 0 10px rgba(255, 50, 255, 0.8);
        padding: 0 10px;
      }
      
      @media (max-width: 768px) {
        #custom-cursor { display: none; }
        #info { font-size: 11px; bottom: 15px; }
      }
    </style>
  </head>
  <body>
    <div id="custom-cursor"></div>
    <div id="info">Toque/Clique para EXPLOSÃO ÉPICA</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js"></script>
    <script>
      let particles = [];
      let numParticles;
      let explosionForce = 0;
      let colorShift = 0;
      let explosionX = 0;
      let explosionY = 0;
      let shockwave = 0;
      let isMobile = false;
      let textRevealMask;
      
      function setup() {
        createCanvas(windowWidth, windowHeight);
        
        // Detecta mobile e ajusta partículas
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        numParticles = isMobile ? 1000 : 2000;
        
        // Inicializa partículas
        for (let i = 0; i < numParticles; i++) {
          particles.push(new Particle(random(width), random(height)));
        }
        
        // Cria máscara do texto
        textRevealMask = createGraphics(width, height);
      }
      
      function draw() {
        // Background com leve trail
        fill(0, 0, 0, 40);
        rect(0, 0, width, height);
        
        colorShift += 2;
        explosionForce *= 0.88;
        shockwave += 15;
        
        // Desenha shockwave da explosão
        if (shockwave < 500 && explosionForce > 5) {
          noFill();
          strokeWeight(3);
          stroke(255, 100, 255, map(shockwave, 0, 500, 200, 0));
          circle(explosionX, explosionY, shockwave);
          strokeWeight(2);
          stroke(100, 200, 255, map(shockwave, 0, 500, 150, 0));
          circle(explosionX, explosionY, shockwave * 0.7);
        }
        
        // Atualiza máscara do texto
        updateTextMask();
        
        // Partículas de fundo vibrantes
        for (let p of particles) {
          p.update();
          p.show();
        }
        
        // Desenha texto NEGRO com máscara de revelação
        drawHiddenText();
        
        // Cursor (desktop only)
        if (!isMobile) {
          updateCursor();
        }
      }
      
      function updateTextMask() {
        textRevealMask.clear();
        textRevealMask.background(0, 0);
        
        // Desenha áreas iluminadas onde há partículas próximas
        for (let p of particles) {
          let d = dist(p.pos.x, p.pos.y, width/2, height/2);
          if (d < 350) { // Só partículas próximas ao centro revelam
            let alpha = map(d, 0, 350, 180, 0);
            textRevealMask.noStroke();
            textRevealMask.fill(255, 255, 255, alpha);
            textRevealMask.circle(p.pos.x, p.pos.y, p.size * 8);
          }
        }
      }
      
      function drawHiddenText() {
        push();
        
        // Cria buffer do texto
        let textBuffer = createGraphics(width, height);
        textBuffer.clear();
        textBuffer.translate(width / 2, height / 2);
        
        let pulse = sin(frameCount * 0.05) * 3;
        let textSizeVal = isMobile ? 50 + pulse : 90 + pulse;
        
        // Glow colorido VIBRANTE (sempre visível)
        for (let i = 6; i > 0; i--) {
          let glowSize = i * (isMobile ? 4 : 6);
          let glowAlpha = map(i, 0, 6, 150, 15);
          
          let hue = (colorShift * 3) % 360;
          let r = sin(radians(hue)) * 127 + 128;
          let g = sin(radians(hue + 120)) * 127 + 128;
          let b = sin(radians(hue + 240)) * 127 + 128;
          
          textBuffer.stroke(r, g, b, glowAlpha);
          textBuffer.strokeWeight(glowSize);
          textBuffer.noFill();
          textBuffer.textAlign(CENTER, CENTER);
          textBuffer.textSize(textSizeVal);
          textBuffer.textStyle(BOLD);
          textBuffer.text("CASTANHO.ME", 0, 0);
        }
        
        // Texto NEGRO (invisível contra fundo negro)
        textBuffer.noStroke();
        textBuffer.fill(0, 0, 0, 255);
        textBuffer.textAlign(CENTER, CENTER);
        textBuffer.textSize(textSizeVal);
        textBuffer.textStyle(BOLD);
        textBuffer.text("CASTANHO.ME", 0, 0);
        
        // Aplica máscara para revelar apenas onde há partículas
        let maskedText = textBuffer.get();
        maskedText.mask(textRevealMask);
        
        image(maskedText, 0, 0);
        
        pop();
        
        // Sparkles ao redor do texto
        push();
        translate(width / 2, height / 2);
        let numSparkles = isMobile ? 5 : 8;
        for (let i = 0; i < numSparkles; i++) {
          let angle = (frameCount * 0.02 + i * TWO_PI / numSparkles);
          let radius = (isMobile ? 120 : 180) + sin(frameCount * 0.03 + i) * 20;
          let x = cos(angle) * radius;
          let y = sin(angle) * radius;
          
          let sparkleSize = 3 + sin(frameCount * 0.1 + i) * 2;
          
          noStroke();
          fill(255, 255, 0, 200);
          circle(x, y, sparkleSize * 2);
          fill(255, 255, 255, 255);
          circle(x, y, sparkleSize);
        }
        pop();
      }
      
      function updateCursor() {
        let cursor = document.getElementById('custom-cursor');
        if (cursor) {
          cursor.style.left = (mouseX - 17.5) + 'px';
          cursor.style.top = (mouseY - 17.5) + 'px';
          
          if (mouseIsPressed) {
            cursor.style.transform = 'scale(1.5)';
            cursor.style.borderColor = 'rgba(255, 255, 0, 1)';
          } else {
            cursor.style.transform = 'scale(1)';
            cursor.style.borderColor = 'rgba(255, 50, 255, 0.9)';
          }
        }
      }
      
      function createExplosion(x, y) {
        explosionForce = 35;
        explosionX = x;
        explosionY = y;
        shockwave = 0;
        
        let explosionPos = createVector(x, y);
        
        // EXPLOSÃO ÉPICA
        for (let p of particles) {
          let d = dist(p.pos.x, p.pos.y, x, y);
          if (d < 400) {
            let force = p5.Vector.sub(p.pos, explosionPos);
            force.normalize();
            force.mult(map(d, 0, 400, 25, 5));
            p.vel.add(force);
          }
        }
        
        // Adiciona partículas extras na explosão
        let extraParticles = isMobile ? 30 : 50;
        for (let i = 0; i < extraParticles; i++) {
          let angle = random(TWO_PI);
          let speed = random(3, 10);
          let px = x + cos(angle) * 5;
          let py = y + sin(angle) * 5;
          let newP = new Particle(px, py);
          newP.vel.set(cos(angle) * speed, sin(angle) * speed);
          newP.lifespan = 100;
          particles.push(newP);
        }
      }
      
      function mousePressed() {
        createExplosion(mouseX, mouseY);
        return false;
      }
      
      function touchStarted() {
        for (let i = 0; i < touches.length; i++) {
          createExplosion(touches[i].x, touches[i].y);
        }
        return false;
      }
      
      function keyPressed() {
        if (key === ' ') {
          particles = particles.filter(p => !p.lifespan || p.lifespan > 0);
        }
      }
      
      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        textRevealMask = createGraphics(width, height);
      }
      
      class Particle {
        constructor(x, y) {
          this.pos = createVector(x, y);
          this.vel = createVector(random(-0.5, 0.5), random(-0.5, 0.5));
          this.acc = createVector(0, 0);
          this.size = random(2, 5);
          this.offset = random(1000);
          this.lifespan = null;
          this.rotation = random(TWO_PI);
          this.rotSpeed = random(-0.05, 0.05);
        }
        
        update() {
          // Movimento perpétuo vibrante
          let flowAngle = noise(this.pos.x * 0.005, this.pos.y * 0.005, frameCount * 0.01) * TWO_PI * 2;
          let flowForce = createVector(cos(flowAngle), sin(flowAngle));
          flowForce.mult(0.3);
          this.acc.add(flowForce);
          
          let d = dist(this.pos.x, this.pos.y, mouseX, mouseY);
          
          // Interação forte com mouse/touch
          let interactionX = isMobile && touches.length > 0 ? touches[0].x : mouseX;
          let interactionY = isMobile && touches.length > 0 ? touches[0].y : mouseY;
          d = dist(this.pos.x, this.pos.y, interactionX, interactionY);
          
          if (d < 150) {
            let force = p5.Vector.sub(this.pos, createVector(interactionX, interactionY));
            force.normalize();
            force.mult(map(d, 0, 150, 15, 0));
            this.acc.add(force);
          }
          
          this.vel.add(this.acc);
          this.vel.limit(6);
          this.vel.mult(0.98);
          this.pos.add(this.vel);
          this.acc.mult(0);
          
          this.rotation += this.rotSpeed;
          
          if (this.lifespan !== null) {
            this.lifespan--;
          }
          
          // Wrap around
          if (this.pos.x < -10) this.pos.x = width + 10;
          if (this.pos.x > width + 10) this.pos.x = -10;
          if (this.pos.y < -10) this.pos.y = height + 10;
          if (this.pos.y > height + 10) this.pos.y = -10;
        }
        
        show() {
          if (this.lifespan !== null && this.lifespan <= 0) return;
          
          let interactionX = isMobile && touches.length > 0 ? touches[0].x : mouseX;
          let interactionY = isMobile && touches.length > 0 ? touches[0].y : mouseY;
          let d = dist(this.pos.x, this.pos.y, interactionX, interactionY);
          let alpha = this.lifespan !== null ? map(this.lifespan, 0, 100, 0, 255) : 255;
          
          push();
          translate(this.pos.x, this.pos.y);
          rotate(this.rotation);
          
          noStroke();
          
          if (d < 180) {
            // SUPER vibrante perto do mouse/touch
            let intensity = map(d, 0, 180, 255, 80);
            
            fill(255, intensity, 255, alpha * 0.6);
            circle(0, 0, this.size * 4);
            
            fill(255, 255, intensity, alpha * 0.8);
            circle(0, 0, this.size * 2);
            
            fill(255, 255, 100, alpha);
            circle(0, 0, this.size);
            
            fill(255, 255, 255, alpha);
            circle(0, 0, this.size * 0.4);
          } else {
            // Cores vibrantes em movimento
            let hue = (colorShift * 2 + this.offset) % 360;
            let r = sin(radians(hue)) * 127 + 128;
            let g = sin(radians(hue + 120)) * 127 + 128;
            let b = sin(radians(hue + 240)) * 127 + 128;
            
            fill(r, g, b, alpha * 0.4);
            circle(0, 0, this.size * 2.5);
            
            fill(r, g, b, alpha);
            circle(0, 0, this.size);
          }
          
          pop();
        }
      }
      
      // Limpa partículas mortas periodicamente
      setInterval(() => {
        particles = particles.filter(p => !p.lifespan || p.lifespan > 0);
        if (particles.length < numParticles) {
          for (let i = particles.length; i < numParticles; i++) {
            particles.push(new Particle(random(width), random(height)));
          }
        }
      }, 2000);
    </script>
  </body>
</html>
