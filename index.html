<!DOCTYPE html>
<html lang="pt-PT">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACESSO DETECTADO</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        background: #000;
        color: #0f0;
        font-family: 'Courier New', monospace;
        overflow: hidden;
        cursor: none;
      }
      
      #terminal {
        padding: 20px;
        height: 100vh;
        overflow-y: auto;
        overflow-x: hidden;
        font-size: 14px;
        line-height: 1.6;
        animation: flicker 0.15s infinite;
      }
      
      @keyframes flicker {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.97; }
      }
      
      .line {
        margin: 2px 0;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      
      .warning {
        color: #ff0000;
        font-weight: bold;
        text-shadow: 0 0 5px #ff0000;
        animation: blink 1s infinite;
      }
      
      @keyframes blink {
        0%, 50%, 100% { opacity: 1; }
        25%, 75% { opacity: 0; }
      }
      
      .header {
        color: #ff0000;
        font-size: 16px;
        font-weight: bold;
        text-shadow: 0 0 10px #ff0000;
        margin: 10px 0;
      }
      
      .success {
        color: #0ff;
        text-shadow: 0 0 5px #0ff;
      }
      
      .data {
        color: #fff;
        text-shadow: 0 0 3px #0f0;
      }
      
      .prompt {
        color: #0f0;
      }
      
      .cursor {
        display: inline-block;
        width: 8px;
        height: 16px;
        background: #0f0;
        animation: cursor-blink 0.8s infinite;
        margin-left: 2px;
      }
      
      @keyframes cursor-blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
      }
      
      #scanlines {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0) 50%,
          rgba(0, 255, 0, 0.02) 50%
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 1000;
      }
      
      #custom-cursor {
        position: fixed;
        width: 20px;
        height: 20px;
        border: 2px solid #0f0;
        pointer-events: none;
        z-index: 10000;
        box-shadow: 0 0 10px #0f0;
      }
      
      ::-webkit-scrollbar {
        width: 10px;
      }
      
      ::-webkit-scrollbar-track {
        background: #000;
      }
      
      ::-webkit-scrollbar-thumb {
        background: #0f0;
        box-shadow: 0 0 10px #0f0;
      }
    </style>
  </head>
  <body>
    <div id="scanlines"></div>
    <div id="custom-cursor"></div>
    <div id="terminal"></div>
    
    <script>
      const terminal = document.getElementById('terminal');
      let lineIndex = 0;
      
      // Atualiza cursor customizado
      document.addEventListener('mousemove', (e) => {
        const cursor = document.getElementById('custom-cursor');
        cursor.style.left = e.clientX - 10 + 'px';
        cursor.style.top = e.clientY - 10 + 'px';
      });
      
      function addLine(text, className = '', delay = 0) {
        return new Promise((resolve) => {
          setTimeout(() => {
            const line = document.createElement('div');
            line.className = `line ${className}`;
            line.textContent = text;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            resolve();
          }, delay);
        });
      }
      
      function typeText(text, className = '', speed = 30) {
        return new Promise((resolve) => {
          const line = document.createElement('div');
          line.className = `line ${className}`;
          terminal.appendChild(line);
          
          let i = 0;
          const cursor = document.createElement('span');
          cursor.className = 'cursor';
          
          const interval = setInterval(() => {
            if (i < text.length) {
              line.textContent = text.substring(0, i + 1);
              line.appendChild(cursor);
              i++;
              terminal.scrollTop = terminal.scrollHeight;
            } else {
              cursor.remove();
              clearInterval(interval);
              resolve();
            }
          }, speed);
        });
      }
      
      // Função para obter IP com múltiplos serviços
      async function getIPAddress() {
        const services = [
          { url: 'https://api.ipify.org?format=json', key: 'ip' },
          { url: 'https://api.my-ip.io/v2/ip.json', key: 'ip' },
          { url: 'https://ipapi.co/json/', key: 'ip' },
          { url: 'https://api.bigdatacloud.net/data/client-ip', key: 'ipString' },
          { url: 'https://geolocation-db.com/json/', key: 'IPv4' }
        ];
        
        for (const service of services) {
          try {
            const response = await fetch(service.url);
            const data = await response.json();
            if (data[service.key]) {
              return { ip: data[service.key], fullData: data };
            }
          } catch (e) {
            console.log(`Serviço ${service.url} falhou, tentando próximo...`);
          }
        }
        return null;
      }
      
      // Função para obter geolocalização detalhada
      async function getGeoLocation(ip) {
        const services = [
          `https://ipapi.co/${ip}/json/`,
          `https://ipwhois.app/json/${ip}`,
          `https://ip-api.com/json/${ip}`,
        ];
        
        for (const service of services) {
          try {
            const response = await fetch(service);
            const data = await response.json();
            if (data && (data.city || data.country)) {
              return data;
            }
          } catch (e) {
            console.log(`Serviço de geo ${service} falhou, tentando próximo...`);
          }
        }
        return null;
      }
      
      async function detectEverything() {
        // Header assustador
        await addLine('═'.repeat(80), 'warning');
        await typeText('██╗    ██╗ █████╗ ██████╗ ███╗   ██╗██╗███╗   ██╗ ██████╗ ', 'warning', 20);
        await typeText('██║    ██║██╔══██╗██╔══██╗████╗  ██║██║████╗  ██║██╔════╝ ', 'warning', 20);
        await typeText('██║ █╗ ██║███████║██████╔╝██╔██╗ ██║██║██╔██╗ ██║██║  ███╗', 'warning', 20);
        await typeText('██║███╗██║██╔══██║██╔══██╗██║╚██╗██║██║██║╚██╗██║██║   ██║', 'warning', 20);
        await typeText('╚███╔███╔╝██║  ██║██║  ██║██║ ╚████║██║██║ ╚████║╚██████╔╝', 'warning', 20);
        await typeText(' ╚══╝╚══╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝╚═╝  ╚═══╝ ╚═════╝ ', 'warning', 20);
        await addLine('═'.repeat(80), 'warning');
        await addLine('');
        
        await typeText('⚠️  ACESSO NÃO AUTORIZADO DETECTADO ⚠️', 'warning', 50);
        await addLine('');
        await typeText('Iniciando protocolo de rastreamento...', 'success', 40);
        await addLine('');
        
        // Simula scanning
        await typeText('[*] Estabelecendo conexão segura...', 'prompt', 30);
        await addLine('[✓] Conexão estabelecida', 'success', 300);
        await addLine('');
        
        await typeText('[*] Coletando informações do invasor...', 'prompt', 30);
        await typeText('[*] Triangulando localização...', 'prompt', 30);
        await addLine('');
        
        // Obtém IP usando múltiplos serviços
        await addLine('┌─ INFORMAÇÃO DE REDE', 'header', 200);
        await typeText('├─ Escaneando endereço IP...', 'prompt', 20);
        
        const ipResult = await getIPAddress();
        
        if (ipResult && ipResult.ip) {
          await addLine(`├─ IP Público: ${ipResult.ip}`, 'warning', 100);
          
          // Obtém geolocalização detalhada
          await typeText('├─ Consultando banco de dados de localização...', 'prompt', 20);
          const geoData = await getGeoLocation(ipResult.ip);
          
          if (geoData) {
            await addLine(`├─ ISP: ${geoData.org || geoData.isp || geoData.connection?.isp || 'Desconhecido'}`, 'data', 100);
            await addLine(`├─ Tipo de Conexão: ${geoData.connection?.connection_type || geoData.type || 'Desconhecido'}`, 'data', 100);
            await addLine(`├─ Cidade: ${geoData.city || 'Desconhecida'}`, 'data', 100);
            await addLine(`├─ Região: ${geoData.region || geoData.region_name || 'Desconhecida'}`, 'data', 100);
            await addLine(`├─ País: ${geoData.country_name || geoData.country || 'Desconhecido'}`, 'data', 100);
            await addLine(`├─ Código País: ${geoData.country_code || geoData.countryCode || 'XX'}`, 'data', 100);
            await addLine(`├─ Continente: ${geoData.continent || 'Desconhecido'}`, 'data', 100);
            await addLine(`├─ Código Postal: ${geoData.postal || geoData.zip || 'Desconhecido'}`, 'data', 100);
            await addLine(`├─ Latitude: ${geoData.latitude || geoData.lat || 'Desconhecida'}`, 'data', 100);
            await addLine(`├─ Longitude: ${geoData.longitude || geoData.lon || 'Desconhecida'}`, 'data', 100);
            await addLine(`├─ Timezone: ${geoData.timezone || 'Desconhecido'}`, 'data', 100);
            await addLine(`├─ UTC Offset: ${geoData.utc_offset || 'Desconhecido'}`, 'data', 100);
            await addLine(`├─ Código de Área: ${geoData.calling_code || geoData.country_calling_code || 'Desconhecido'}`, 'data', 100);
            await addLine(`├─ Moeda: ${geoData.currency || geoData.currency_name || 'Desconhecida'}`, 'data', 100);
            await addLine(`├─ ASN: ${geoData.asn || 'Desconhecido'}`, 'data', 100);
            
            // Se tiver coordenadas, mostrar link do Google Maps
            if (geoData.latitude && geoData.longitude) {
              await addLine(`├─ Google Maps: https://maps.google.com/?q=${geoData.latitude},${geoData.longitude}`, 'warning', 100);
            }
          }
          
          // Informações adicionais do fullData se disponível
          if (ipResult.fullData) {
            if (ipResult.fullData.hostname) {
              await addLine(`├─ Hostname: ${ipResult.fullData.hostname}`, 'data', 100);
            }
            if (ipResult.fullData.anycast !== undefined) {
              await addLine(`├─ Anycast: ${ipResult.fullData.anycast ? 'SIM' : 'NÃO'}`, 'data', 100);
            }
          }
          
          await addLine(`└─ [LOCALIZAÇÃO RASTREADA COM SUCESSO]`, 'success', 100);
        } else {
          await addLine('├─ IP Público: [ERRO - Firewall detectado]', 'warning', 100);
          await addLine('└─ Tentando bypass...', 'prompt', 100);
        }
        
        await addLine('');
        
        // Informações do navegador
        await addLine('┌─ INFORMAÇÃO DO NAVEGADOR', 'header', 200);
        await addLine(`├─ User Agent: ${navigator.userAgent}`, 'data', 100);
        await addLine(`├─ Plataforma: ${navigator.platform}`, 'data', 100);
        await addLine(`├─ Idioma Principal: ${navigator.language}`, 'data', 100);
        await addLine(`├─ Idiomas Aceitos: ${navigator.languages.join(', ')}`, 'data', 100);
        await addLine(`├─ Online: ${navigator.onLine ? 'SIM' : 'NÃO'}`, 'data', 100);
        await addLine(`├─ Cookies Habilitados: ${navigator.cookieEnabled ? 'SIM' : 'NÃO'}`, 'data', 100);
        await addLine(`├─ DoNotTrack: ${navigator.doNotTrack || 'Não configurado'}`, 'data', 100);
        await addLine(`├─ Vendor: ${navigator.vendor}`, 'data', 100);
        await addLine(`├─ App Name: ${navigator.appName}`, 'data', 100);
        await addLine(`├─ App Version: ${navigator.appVersion}`, 'data', 100);
        await addLine(`├─ Product: ${navigator.product}`, 'data', 100);
        await addLine(`└─ Hardware Concurrency: ${navigator.hardwareConcurrency || 'Desconhecido'} cores`, 'data', 100);
        await addLine('');
        
        // Informações de tela
        await addLine('┌─ INFORMAÇÃO DO DISPLAY', 'header', 200);
        await addLine(`├─ Resolução Total: ${screen.width}x${screen.height}`, 'data', 100);
        await addLine(`├─ Resolução Disponível: ${screen.availWidth}x${screen.availHeight}`, 'data', 100);
        await addLine(`├─ Profundidade de Cor: ${screen.colorDepth} bits`, 'data', 100);
        await addLine(`├─ Profundidade de Pixel: ${screen.pixelDepth} bits`, 'data', 100);
        await addLine(`├─ Device Pixel Ratio: ${window.devicePixelRatio}`, 'data', 100);
        await addLine(`├─ Orientação: ${screen.orientation ? screen.orientation.type : 'Desconhecida'}`, 'data', 100);
        await addLine(`└─ Touch Screen: ${navigator.maxTouchPoints > 0 ? 'SIM (' + navigator.maxTouchPoints + ' pontos de toque)' : 'NÃO'}`, 'data', 100);
        await addLine('');
        
        // Informações da janela
        await addLine('┌─ INFORMAÇÃO DA JANELA DO NAVEGADOR', 'header', 200);
        await addLine(`├─ Tamanho Interno: ${window.innerWidth}x${window.innerHeight}`, 'data', 100);
        await addLine(`├─ Tamanho Externo: ${window.outerWidth}x${window.outerHeight}`, 'data', 100);
        await addLine(`├─ Posição na Tela: X=${window.screenX}, Y=${window.screenY}`, 'data', 100);
        await addLine(`└─ Posição de Scroll: X=${window.scrollX}, Y=${window.scrollY}`, 'data', 100);
        await addLine('');
        
        // Detecção de bateria (se disponível)
        if ('getBattery' in navigator) {
          try {
            const battery = await navigator.getBattery();
            await addLine('┌─ INFORMAÇÃO DE BATERIA', 'header', 200);
            await addLine(`├─ Nível de Carga: ${(battery.level * 100).toFixed(0)}%`, 'data', 100);
            await addLine(`├─ Estado: ${battery.charging ? 'CARREGANDO' : 'DESCARREGANDO'}`, 'data', 100);
            await addLine(`├─ Tempo para Carga Completa: ${battery.chargingTime === Infinity ? 'N/A' : Math.floor(battery.chargingTime / 60) + ' minutos'}`, 'data', 100);
            await addLine(`└─ Tempo de Bateria Restante: ${battery.dischargingTime === Infinity ? 'N/A' : Math.floor(battery.dischargingTime / 60) + ' minutos'}`, 'data', 100);
            await addLine('');
          } catch (e) {
            console.log('Bateria não disponível');
          }
        }
        
        // Informações de conexão (se disponível)
        if ('connection' in navigator || 'mozConnection' in navigator || 'webkitConnection' in navigator) {
          const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
          await addLine('┌─ INFORMAÇÃO DE CONEXÃO DE REDE', 'header', 200);
          await addLine(`├─ Tipo Efetivo: ${connection.effectiveType || 'Desconhecido'}`, 'data', 100);
          await addLine(`├─ Velocidade Download: ${connection.downlink || 'Desconhecida'} Mbps`, 'data', 100);
          await addLine(`├─ Latência (RTT): ${connection.rtt || 'Desconhecida'} ms`, 'data', 100);
          await addLine(`└─ Modo Economia de Dados: ${connection.saveData ? 'ATIVADO' : 'DESATIVADO'}`, 'data', 100);
          await addLine('');
        }
        
        // Detecção de memória (se disponível)
        if ('deviceMemory' in navigator) {
          await addLine('┌─ INFORMAÇÃO DE HARDWARE', 'header', 200);
          await addLine(`├─ Memória RAM do Dispositivo: ${navigator.deviceMemory} GB`, 'data', 100);
          await addLine(`└─ Núcleos de CPU: ${navigator.hardwareConcurrency}`, 'data', 100);
          await addLine('');
        }
        
        // Plugins instalados
        if (navigator.plugins && navigator.plugins.length > 0) {
          await addLine('┌─ PLUGINS/EXTENSÕES DETECTADOS', 'header', 200);
          for (let i = 0; i < Math.min(navigator.plugins.length, 15); i++) {
            const prefix = i === Math.min(navigator.plugins.length, 15) - 1 ? '└─' : '├─';
            await addLine(`${prefix} ${navigator.plugins[i].name} (${navigator.plugins[i].filename})`, 'data', 50);
          }
          if (navigator.plugins.length > 15) {
            await addLine(`   ... e mais ${navigator.plugins.length - 15} plugins`, 'data', 50);
          }
          await addLine('');
        }
        
        // Timezone
        await addLine('┌─ INFORMAÇÃO TEMPORAL', 'header', 200);
        const now = new Date();
        await addLine(`├─ Data/Hora Local: ${now.toLocaleString('pt-PT')}`, 'data', 100);
        await addLine(`├─ Timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}`, 'data', 100);
        await addLine(`├─ Offset UTC: ${now.getTimezoneOffset() / -60} horas`, 'data', 100);
        await addLine(`├─ Timestamp Unix: ${now.getTime()}`, 'data', 100);
        await addLine(`└─ Dia da Semana: ${now.toLocaleDateString('pt-PT', { weekday: 'long' })}`, 'data', 100);
        await addLine('');
        
        // Canvas Fingerprinting
        await addLine('┌─ FINGERPRINT ÚNICO DO DISPOSITIVO', 'header', 200);
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(0, 0, 100, 50);
        ctx.fillStyle = '#069';
        ctx.fillText('Fingerprint', 2, 2);
        const fingerprint = canvas.toDataURL();
        const hash = fingerprint.split(',')[1].slice(-64);
        await addLine(`├─ Canvas Fingerprint Hash: ${hash}`, 'warning', 100);
        
        // WebGL info
        try {
          const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
          const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
          await addLine(`├─ GPU Vendor: ${gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL)}`, 'warning', 100);
          await addLine(`├─ GPU Renderer: ${gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)}`, 'warning', 100);
          await addLine(`└─ WebGL Version: ${gl.getParameter(gl.VERSION)}`, 'data', 100);
        } catch (e) {
          await addLine(`└─ GPU: [INFORMAÇÃO BLOQUEADA/PROTEGIDA]`, 'data', 100);
        }
        await addLine('');
        
        // Fontes do sistema (aproximação)
        await addLine('┌─ DETECÇÃO DE FONTES DO SISTEMA', 'header', 200);
        const fonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia', 'Palatino', 'Garamond', 'Comic Sans MS', 'Trebuchet MS', 'Impact'];
        const detectedFonts = [];
        for (const font of fonts) {
          const detected = document.fonts.check(`12px "${font}"`);
          if (detected) detectedFonts.push(font);
        }
        await addLine(`└─ Fontes Detectadas: ${detectedFonts.join(', ')}`, 'data', 100);
        await addLine('');
        
        // Permissões
        await addLine('┌─ ESTADO DAS PERMISSÕES DO NAVEGADOR', 'header', 200);
        const permissions = ['geolocation', 'notifications', 'camera', 'microphone'];
        for (let i = 0; i < permissions.length; i++) {
          try {
            const result = await navigator.permissions.query({ name: permissions[i] });
            const prefix = i === permissions.length - 1 ? '└─' : '├─';
            const state = result.state.toUpperCase();
            const stateClass = state === 'GRANTED' ? 'warning' : 'data';
            await addLine(`${prefix} ${permissions[i]}: ${state}`, stateClass, 100);
          } catch (e) {
            const prefix = i === permissions.length - 1 ? '└─' : '├─';
            await addLine(`${prefix} ${permissions[i]}: NÃO SUPORTADO`, 'data', 100);
          }
        }
        await addLine('');
        
        // Headers de referência
        await addLine('┌─ INFORMAÇÃO DE NAVEGAÇÃO E SESSÃO', 'header', 200);
        await addLine(`├─ URL Atual: ${window.location.href}`, 'data', 100);
        await addLine(`├─ Protocolo: ${window.location.protocol}`, 'data', 100);
        await addLine(`├─ Host: ${window.location.host}`, 'data', 100);
        await addLine(`├─ Pathname: ${window.location.pathname}`, 'data', 100);
        await addLine(`├─ Referrer: ${document.referrer || 'Acesso direto (sem referrer)'}`, 'data', 100);
        await addLine(`├─ Histórico de Navegação: ${window.history.length} entradas`, 'data', 100);
        await addLine(`└─ Modo de Navegação: ${window.navigator.webdriver ? 'AUTOMAÇÃO DETECTADA!' : 'Normal'}`, 'data', 100);
        await addLine('');
        
        // Media Devices
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            await addLine('┌─ DISPOSITIVOS DE MÍDIA DETECTADOS', 'header', 200);
            const audioInputs = devices.filter(d => d.kind === 'audioinput').length;
            const videoInputs = devices.filter(d => d.kind === 'videoinput').length;
            const audioOutputs = devices.filter(d => d.kind === 'audiooutput').length;
            await addLine(`├─ Microfones: ${audioInputs}`, 'data', 100);
            await addLine(`├─ Câmeras: ${videoInputs}`, 'data', 100);
            await addLine(`└─ Alto-falantes: ${audioOutputs}`, 'data', 100);
            await addLine('');
          } catch (e) {
            console.log('Media devices não acessíveis');
          }
        }
        
        // Final assustador
        await addLine('═'.repeat(80), 'warning', 500);
        await typeText('⚠️  TODOS OS DADOS FORAM COLETADOS E ARMAZENADOS ⚠️', 'warning', 50);
        await addLine('═'.repeat(80), 'warning');
        await addLine('');
        await typeText('[!] Você foi completamente rastreado.', 'warning', 40);
        await typeText('[!] Todas as informações foram registradas no servidor.', 'warning', 40);
        await typeText('[!] Seu endereço IP foi marcado como ACESSO NÃO AUTORIZADO.', 'warning', 40);
        await typeText('[!] Localização geográfica confirmada e armazenada.', 'warning', 40);
        await typeText('[!] Fingerprint do dispositivo salvo permanentemente.', 'warning', 40);
        await addLine('');
        await typeText('Preparando relatório para autoridades...', 'success', 40);
        await addLine('');
        await typeText('Encerrando conexão em 3...', 'success', 40);
        await addLine('2...', 'success', 1000);
        await addLine('1...', 'success', 1000);
        await addLine('');
        await typeText('████████████████████ 100% COMPLETO ████████████████████', 'warning', 30);
        await addLine('');
        await typeText('[SISTEMA] Dados transmitidos com sucesso.', 'success', 40);
        await typeText('[SISTEMA] Sessão encerrada.', 'success', 40);
        await addLine('');
        await addLine('> _', 'prompt');
      }
      
      // Inicia o scanning
      detectEverything();
    </script>
  </body>
</html>
